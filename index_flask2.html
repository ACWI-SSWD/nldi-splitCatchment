

<!DOCTYPE html>
<html>
<head>
	
	<title>StreamStats open source delineation</title>

	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.5.1/dist/leaflet.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.css"/>
    <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/leaflet@1.5.1/dist/leaflet.js" ></script>
    <script src="https://unpkg.com/esri-leaflet@2.3.0/dist/esri-leaflet.js" ></script>

    <script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/toastr.min.js"></script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/gokertanrisever/leaflet-ruler@master/src/leaflet-ruler.css" integrity="sha384-P9DABSdtEY/XDbEInD3q+PlL+BjqPCXGcF8EkhtKSfSTr/dS5PBKa9+/PMkW2xsY" crossorigin="anonymous">  
    <script src="https://cdn.jsdelivr.net/gh/gokertanrisever/leaflet-ruler@master/src/leaflet-ruler.js" integrity="sha384-N2S8y7hRzXUPiepaSiUvBH1ZZ7Tc/ZfchhbPdvOE5v3aBBCIepq9l+dBJPFdo1ZJ" crossorigin="anonymous"></script>

    <!-- Easy Button -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-easybutton@2/src/easy-button.css">
    <script src="https://cdn.jsdelivr.net/npm/leaflet-easybutton@2/src/easy-button.js"></script>


	<style>

        body {
            font-family: 'Roboto', sans-serif;
            padding: 0;
            margin: 0;
        }
        html, body, #map {
            height: 100%;
            width: 100%;
        }

        .leaflet-control-layers:hover {
            cursor: pointer;
        }

        body.delineate * { cursor: crosshair; }
	</style>
</head>
<body>

<div id='map'></div>

<script>
var map;
var startPoint, border, catchment, splitCatchment, upstreamBasin, mergedCatchment, streamCrossSection;
var intersectionPoint, raindropPath, nhdFlowline, upstreamFlowline, downstreamFlowline, downstreamPath;
var features;
var layerControl;
var streamGridLayer;
var loadingToast;
var startTime;
var region;
var runsplitcatchment = true;
var runxstool = false;
var truefalse = 'True';
var direction = 'down';
var query = false;
var res = 10;

//main document ready function
$(document).ready(function () {

    toastr.options = {
        "positionClass": "toast-bottom-right",
    }

	//initialize basemap
	var natGeo = L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer/tile/{z}/{y}/{x}', {
		attribution: 'Tiles &copy; Esri &mdash; Esri, DeLorme, NAVTEQ',
		maxZoom: 16
	});

	//initialize map
	map = new L.Map('map', {
		center: new L.LatLng(41.75, -93),
		zoom: 7,
		layers: natGeo,
		attributionControl: false,
        zoomControl: false
	});

    var delineateButton = L.easyButton(
        {
            states: [{
                stateName: 'delineate_off',        // name the state
                icon:      '<strong>On</strong>',               // and define its properties
                title:     'Delineate off',      // like its title
                onClick: function(control) {       // and its callback
                    control.state('delineate_on');
                    map.off('click', delineatePoint);
                }
            }, {
                stateName: 'delineate_on',
                icon:      '<strong>Off</strong>',
                title:     'Delineate on',
                onClick: function(control) {
                    control.state('delineate_off');
                    map.on('click', delineatePoint);
                }
            }
        ]
    })

    delineateButton.addTo(map);

    var functionButton = L.easyButton(
        {
            states: [{
                stateName: 'run-splitcatchment',        // name the state
                icon:      '<strong>S</strong>',               // and define its properties
                title:     'Splitcatchment',      // like its title
                onClick: function(control) {       // and its callback
                    control.state('run-flowtrace');
                    runsplitcatchment = false ;   // change state on click!
                    directionButton.addTo(map);
                }
            }, {
                stateName: 'run-flowtrace',
                icon:      '<strong>F</strong>',
                title:     'Flowtrace',
                onClick: function(control) {
                    control.state('run-dem_query');
                    query = true;
                    
                    directionButton.remove(map);
                    truefalseButton.remove(map);
                }
            }, {
                stateName: 'run-dem_query',
                icon:      '<strong>DQ</strong>',
                title:     'DEM Query',
                onClick: function(control) {
                    control.state('run-xstool');
                    runxstool = true;
                    runsplitcatchment = false ;
                    query = false ;
                    resolutionButton.addTo(map)
                }
            }, {
                stateName: 'run-xstool',
                icon:      '<strong>XS</strong>',
                title:     'Stream Crosssection',
                onClick: function(control) {
                    control.state('run-splitcatchment');
                    runsplitcatchment = true;
                    runxstool = false;
                    truefalseButton.addTo(map);
                    resolutionButton.remove(map)
                }
            }
        ]
    })

    functionButton.addTo(map);

    var truefalseButton = L.easyButton(
        {
            states: [{
                stateName: 'true',        // name the state
                icon:      '<strong>True</strong>',               // and define its properties
                title:     'True',      // like its title
                onClick: function(control) {       // and its callback
                    control.state('false');
                    truefalse = null ;   // change state on click!
                }
            }, {
                stateName: 'false',
                icon:      '<strong>False</strong>',
                title:     'False',
                onClick: function(control) {
                    control.state('true');
                    truefalse = 'True';
                }
            }]
    })
    truefalseButton.addTo(map);

    var directionButton = L.easyButton(
        {
            states: [{
                stateName:  'down',
                icon:       '<strong>Down</strong>',
                title:      'Downstream',
                onClick: function(control) {
                    control.state('up');
                    direction = 'up';
                }
            },{
                stateName:  'up',
                icon:       '<strong>Up</strong>',
                title:      'Upstream',
                onClick: function(control) {
                    control.state('none');
                    direction = 'none';
                }
            },{
                stateName:  'none',
                icon:       '<strong>Entire</strong>',
                title:      'Entire',
                onClick: function(control) {
                    control.state('down');
                    direction = 'down';
                }

            }]

    })

    var resolutionButton = L.easyButton(
        {
            states: [{
                stateName:  '10m',
                icon:       '<strong>10m</strong>',
                title:      '10m DEM',
                onClick: function(control) {
                    control.state('30m');
                    res = 30;
                }

            },{
                stateName:  '30m',
                icon:       '<strong>30m</strong>',
                title:      '30m DEM',
                onClick: function(control) {
                    control.state('60m');
                    res = 60;
                }

            },{
                stateName:  '60m',
                icon:       '<strong>60m</strong>',
                title:      '60m DEM',
                onClick: function(control) {
                    control.state('1m');
                    res = 1;
                }

            },{
                stateName:  '1m',
                icon:       '<strong>1m</strong>',
                title:      '1m DEM',
                onClick: function(control) {
                    control.state('3m');
                    res = 3;
                }
            },{
                stateName:  '3m',
                icon:       '<strong>3m</strong>',
                title:      '3m DEM',
                onClick: function(control) {
                    control.state('5m');
                    res = 5;
                }
            },{
                stateName:  '5m',
                icon:       '<strong>5m</strong>',
                title:      '5m DEM',
                onClick: function(control) {
                    control.state('10m');
                    res = 10;
                }

            } ]

    })
    


    layerControl = L.control.layers({'natGeo Basemap': natGeo}).addTo(map);
    var options = {
      position: 'topright',         // Leaflet control position option
      circleMarker: {               // Leaflet circle marker options for points used in this plugin
        color: 'red',
        radius: 2
      },
      lineStyle: {                  // Leaflet polyline options for lines used in this plugin
        color: 'red',
        dashArray: '1,6'
      },
      lengthUnit: {                 // You can use custom length units. Default unit is kilometers.
        display: 'm',              // This is the display value will be shown on the screen. Example: 'meters'
        decimal: 2,                 // Distance result will be fixed to this value. 
        factor: 1000,               // This value will be used to convert from kilometers. Example: 1000 (from kilometers to meters)  
        label: 'Distance:'           
      },
      angleUnit: {
        display: '&deg;',           // This is the display value will be shown on the screen. Example: 'Gradian'
        decimal: 2,                 // Bearing result will be fixed to this value.
        factor: null,                // This option is required to customize angle unit. Specify solid angle value for angle unit. Example: 400 (for gradian).
        label: 'Bearing:'
      }
    }
    L.control.ruler(options).addTo(map);


    //show str900 grid
    var url = 'https://gis.streamstats.usgs.gov/arcgis/rest/services/StreamStats/stateServices/MapServer';
    streamGridLayer = L.esri.dynamicMapLayer({
        url: url,
        layers: [99,59]
    }).addTo(map);
    layerControl.addOverlay(streamGridLayer , "str900");

    //container featuregroup used for zooming
    features = L.featureGroup();

    map.on('zoomend', changeCursor );

    //click listener for delineation start
    map.on('click', delineatePoint)
    
    
});

function changeCursor() {
    if (map.getZoom() >= 4) {
        console.log('ready to delineate')    
        document.body.classList.add('delineate');
    }
    else {
        document.body.classList.remove('delineate');
    }
}

function validatePoint(e) {
    var checkPoint = toastr.info('Validating click point', {timeOut: 0});

    if (map.getZoom() < 15) return;

    streamGridLayer.identify().on(map).at(e.latlng).returnGeometry(false).tolerance(5).layers('visible:99,59')
        .run(function (error, featureCollection, response) {
            console.log(featureCollection, response)
            toastr.clear(checkPoint);
            if (error) {
            console.log(error);
            return;
            }
            if (response.results[0].attributes['Pixel Value'] === '1') {

                // if (response.results[0].layerId == 59) region = 'ma';
                // if (response.results[0].layerId == 99) region = 'ny';
                delineatePoint(e)
            }
            else {
                toastr.warning('Please click on a stream cell');
            }
            
    });
}

function delineatePoint(e) {

    startTime = performance.now();
    loadingToast = toastr.info('Delineating wastershed...', {timeOut: 0});

    features.clearLayers();
    if (startPoint) { 
        layerControl.removeLayer(startPoint);
        map.removeLayer(startPoint)
    }
    if (catchment) {
        layerControl.removeLayer(catchment);
        map.removeLayer(catchment)
    }
    if (splitCatchment) {
        layerControl.removeLayer(splitCatchment);
        map.removeLayer(splitCatchment)
    }
    if (upstreamBasin) {
        layerControl.removeLayer(upstreamBasin);
        map.removeLayer(upstreamBasin)
    }
    if (mergedCatchment) {
        layerControl.removeLayer(mergedCatchment);
        map.removeLayer(mergedCatchment)
    }
    if (intersectionPoint) {
        layerControl.removeLayer(intersectionPoint);
        map.removeLayer(intersectionPoint)
    }
    if (raindropPath) {
        layerControl.removeLayer(raindropPath);
        map.removeLayer(raindropPath)
    }
    if (nhdFlowline) {
        layerControl.removeLayer(nhdFlowline);
        map.removeLayer(nhdFlowline)
    }
    if (upstreamFlowline) {
        layerControl.removeLayer(upstreamFlowline);
        map.removeLayer(upstreamFlowline)
    }
    if (downstreamFlowline) {
        layerControl.removeLayer(downstreamFlowline);
        map.removeLayer(downstreamFlowline)
    }
    if (downstreamPath) {
        layerControl.removeLayer(downstreamPath);
        map.removeLayer(downstreamPath)
    }
    if (streamCrossSection) {
        layerControl.removeLayer(streamCrossSection);
        map.removeLayer(streamCrossSection)
    }

    var data = {
        lat: e.latlng.lat,
        lng: e.latlng.lng,
        runsplitcatchment: runsplitcatchment,
        truefalse: truefalse,
        query: query,
        res: res,
        xstool: runxstool,
        direction: direction
    }

    // var runsplitcatchment = runsplitcatchment
    
    // var data = {
    //     lat: 44.00431,
    //     lng: -73.71348
    // }

    startPoint = L.marker([data.lat,data.lng]).addTo(map);
    if (query == false){
        startPoint.bindPopup('<b> Start Point Coordinates: </b>' + data.lat + ', ' + data.lng );
    }
    
    

    $.ajax({ 
        url: 'http://127.0.0.1:5000/delineate',
        type: 'GET',
        dataType: 'json', // added data type
        data: data,
        success: function (res) {   // success callback function
            console.log('response:', typeof res, res) 

            toastr.clear(loadingToast);
            var endTime = performance.now();
            var totalTime = (endTime - startTime)/1000;
            toastr.info('It took ' + totalTime.toFixed(2) + ' seconds.');
            
            if (query == true) {
                startPoint.bindPopup(
                    '<b>Point Coordinates: </b>' + data.lat + ', ' + data.lng + 
                    '<br><b>1m: </b>' + res.res_1m + '</br>' +
                    '<b>3m: </b>' + res.res_3m +
                    '<br><b>5m: </b>' + res.res_5m + '</br>' +
                    '<b>10m: </b>' + res.res_10m +
                    '<br><b>30m: </b>' + res.res_30m + '</br>' +
                    '<b>60m: </b>' + res.res_60m 
                     ).openPopup();
            }

            for(key in res['features']) {
                item = res['features'][key]
                if (item['id'] == 'catchment') {
                    catchment = L.geoJson(item, { style: function(feature) {
                        return {
                            fillColor: 'yellow',
                            weight: 2,
                            opacity: 1,
                            color: 'yellow',  //Outline color
                            fillOpacity: 0.7         
                        }    
                    }}).addTo(map);
                    catchment.addTo(features)
                    layerControl.addOverlay(catchment , "Catchment");

                }

                if (item['id'] == 'splitCatchment') {
                    //console.log('has split Catchment', res.splitCatchment)
                    splitCatchment = L.geoJson(item, { style: function(feature) {
                        return {
                            fillColor: 'green',
                            weight: 2,
                            opacity: 1,
                            color: 'green',  //Outline color
                            fillOpacity: 0.7         
                        }    
                    }}).addTo(map);
                    splitCatchment.addTo(features)
                    layerControl.addOverlay(splitCatchment , "Split Catchment");

                }

                if (item['id'] == 'upstreamBasin') {
                    //console.log('has adjoint Catchment', res.adjointCatchment)
                    upstreamBasin = L.geoJson(item, { style: function(feature) {
                        return {
                            fillColor: 'red',
                            weight: 2,
                            opacity: 1,
                            color: 'red',  //Outline color
                            fillOpacity: 0.7         
                        }    
                    }}).addTo(map);
                    upstreamBasin.addTo(features)
                    layerControl.addOverlay(upstreamBasin , "Upstream Basin");
                    
                }

                if (item['id'] == 'mergedCatchment') {
                    //console.log('has merged Catchment', res.mergedCatchmentt)
                    mergedCatchment = L.geoJson(item, { style: function(feature) {
                        return {
                            fillColor: 'blue',
                            weight: 2,
                            opacity: 1,
                            color: 'blue',  //Outline color
                            fillOpacity: 0.2        
                        }    
                    }}).addTo(map);
                    mergedCatchment.addTo(features)
                    layerControl.addOverlay(mergedCatchment , "Merged Catchment");
                }

                // if (res.intersectionPoint) {
                //     //console.log('has intersectionPoint', res.intersectionPoint)
                //     intersectionPoint = L.geoJson(res.intersectionPoint).addTo(map);
                //     intersectionPoint.addTo(features)
                //     layerControl.addOverlay(intersectionPoint , "Intersection Point");

                    // intersectionPoint.bindPopup('<b>Stream name: </b>' + res.streamInfo.gnis_name +
                    //                         '<br><b>Comid: </b>' + res.streamInfo.comid + '</br>' +
                    //                         '<b>Reach Code: </b>' + res.streamInfo.reachcode +
                    //                         '<br><b>Measure: </b> 0:' + res.streamInfo.measure + '</br>' +
                    //                         '<b>Raindrop Path Length: </b>' + res.streamInfo.raindropPathDist + ' meters' +
                    //                         '<br><b>Intersection Point: </b>' + res.intersectionPoint.coordinates[1] + ', ' + res.intersectionPoint.coordinates[0] + '</br>').openPopup();

                // }

                if (item['id'] == 'raindropPath') {
                    //console.log('has raindropPath', res.raindropPath)
                    raindropPath = L.geoJson(item, { style: function(feature) {
                        return {
                            fillColor: 'blue',
                            weight: 2,
                            opacity: 1,
                            color: 'blue',  //Outline color
                            fillOpacity: 0.2        
                        }    
                    }}).addTo(map);
                    raindropPath.addTo(features)
                    layerControl.addOverlay(raindropPath , "Raindrop Path");
                }

                if (item['id'] == 'nhdFlowline') {
                    //console.log('has nhdFlowline', res.nhdFlowline)
                    nhdFlowline = L.geoJson(item, { style: function(feature) {
                        return {
                            fillColor: 'yellow',
                            weight: 2,
                            opacity: 1,
                            color: 'yellow',  //Outline color
                            fillOpacity: 0.2        
                        }    
                    }}).addTo(map);
                    nhdFlowline.addTo(features)
                    layerControl.addOverlay(nhdFlowline , "NHD Flowlines");
                    nhdFlowline.bindPopup('<b>Stream name: </b>' + item['properties']['gnis_name'] +
                                            '<br><b>Comid: </b>' + item['properties']['comid'] + '</br>' +
                                            '<b>Reach Code: </b>' + item['properties']['reachcode'] +
                                            '<br><b>Measure: </b> 0:' + item['properties']['measure'] + '</br>' +
                                            '<b>Raindrop Path Length: </b>' + item['properties']['raindropPathDist'] + ' meters' +
                                            '<br><b>Intersection Point: </b>' + item['properties']['intersectionPoint'][0] + ', ' + item['properties']['intersectionPoint'][1] + '</br>').openPopup();

                }
                
                if (item['id'] == 'upstreamFlowline') {
                    // console.log('has upstreamFlowline', res.upstreamFlowline)
                    upstreamFlowline = L.geoJson(item, { style: function(feature) {
                        return {
                            fillColor: 'yellow',
                            weight: 2,
                            opacity: 1,
                            color: 'yellow',  //Outline color
                            fillOpacity: 0.2        
                        }    
                    }}).addTo(map);
                    upstreamFlowline.addTo(features)
                    layerControl.addOverlay(upstreamFlowline , "Upstream Flowlines");
                }

                if (item['id'] == 'downstreamFlowline') {
                    // console.log('has downstreamFlowline', res.downstreamFlowline)
                    downstreamFlowline = L.geoJson(item, { style: function(feature) {
                        return {
                            fillColor: 'yellow',
                            weight: 2,
                            opacity: 1,
                            color: 'yellow',  //Outline color
                            fillOpacity: 0.2        
                        }    
                    }}).addTo(map);
                    downstreamFlowline.addTo(features)
                    layerControl.addOverlay(downstreamFlowline , "Downstream Flowlines");
                }

                if (item['id'] == 'downstreamPath') {
                    // console.log('has downstreamPath', res.downstreamPath)
                    downstreamPath = L.geoJson(item, { style: function(feature) {
                        return {
                            fillColor: 'purple',
                            weight: 2,
                            opacity: 1,
                            color: 'purple',  //Outline color
                            fillOpacity: 0.2        
                        }    
                    }}).addTo(map);
                    downstreamPath.addTo(features)
                    layerControl.addOverlay(downstreamPath , "Downstream Path");
                }
                
                if (item['id'] == 'streamCrossSection') {
                    streamCrossSection = L.geoJson(item, { style: function(feature) {
                        return {
                            fillColor: 'purple',
                            weight: 2,
                            opacity: 1,
                            color: 'purple',  //Outline color
                            fillOpacity: 0.2        
                        }    
                    }}).addTo(map);
                    streamCrossSection.addTo(features)
                    layerControl.addOverlay(streamCrossSection , "Stream Cross Section");
                }

                
            
            //console.log('features:',features)
            map.fitBounds(features.getBounds());
            }
        },
        error: function (jqXHR, status, err) {
            console.log("Local error callback.", status, err);
            toastr.clear(loadingToast);
            toastr.error('There was a problem with the request', {timeOut: 0});
        },
        complete: function() {
            // console.log('after delineate:', data)

            //update URL in address bar even on fail
        //     window.history.pushState('delineate', 'nldi-delineate', './?lat=' + data.lat + '&lng=' + data.lng);
         }

    });


    }

</script>
</body>
</html>